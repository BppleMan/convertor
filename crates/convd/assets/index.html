<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Convertor · Glass Dashboard+</title>
    <style>
        :root{
          --bg:#0b0f14; --card:#0f1722cc; --ringTrack:#22324a; --border:#1f2a3a;
          --ok:#00ffa6; --warn:#ffd166; --bad:#ff4d6d; --txt:#dbe4ee; --muted:#93a4b8;
        }
        *{box-sizing:border-box} html,body{height:100%}
        body{
          margin:0;
          background:radial-gradient(1100px 650px at 20% -10%,#152032 0,#0b0f14 55%,#05070a 100%);
          color:var(--txt);
          font:14px/1.6 ui-monospace, Menlo, Consolas, monospace
        }
        code{background:#0a1420;color:#a3b8ff;border-radius:6px;padding:.1em .35em}
        .page{min-height:100%;display:grid;grid-template-rows:auto auto 1fr auto;gap:14px;padding:20px}
        .header{display:flex;justify-content:space-between;align-items:center;gap:12px}
        .header h1{font-size:16px;margin:0;color:#a9c7ff}
        .actions{display:flex;flex-wrap:wrap;gap:8px}
        button{all:unset;cursor:pointer;padding:8px 12px;border:1px solid #2a3b4a;border-radius:10px;background:#0e1a26;color:#cfe8ff}
        button[disabled]{opacity:.6;cursor:not-allowed}
        .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:14px}
        @media (max-width:1100px){.grid{grid-template-columns:repeat(2,minmax(0,1fr))}}
        @media (max-width:760px){.grid{grid-template-columns:1fr}}
        .card{
          position:relative;display:grid;grid-template-columns:90px 1fr;gap:16px;align-items:center;
          padding:16px;border:1px solid var(--border);border-radius:16px;background:var(--card);backdrop-filter:blur(8px);
          box-shadow:0 10px 40px #0008
        }
        .card.full{grid-column:1/-1; grid-template-columns:1fr}
        .ring{
          width:72px;height:72px;border-radius:50%;display:grid;place-items:center;border:1px solid var(--border);
          background:conic-gradient(var(--ok) 0deg, var(--ok) 0deg, var(--ringTrack) 0deg 360deg)
        }
        .ring span{font-weight:700}
        .kv{display:grid;gap:4px}
        .muted{color:var(--muted)}
        .badge{display:inline-flex;gap:6px;align-items:center}
        .dot{width:10px;height:10px;border-radius:50%}
        .dot.ok{background:var(--ok)} .dot.warn{background:var(--warn)} .dot.bad{background:var(--bad)} .dot.idle{background:#7aa2f7}
        canvas.spark{width:100%;height:70px;display:block;background:#0b1320;border:1px solid var(--border);border-radius:10px}
        .progress{height:8px;background:#0a1420;border:1px solid var(--border);border-radius:10px;overflow:hidden}
        .progress>span{display:block;height:100%;width:0;background:linear-gradient(90deg,#3ab4ff,#00ffa6)}
        .row{display:flex;gap:10px;flex-wrap:wrap}
        .row>label{display:flex;align-items:center;gap:6px}
        input[type="number"], input[type="text"]{
          background:#0a1420;border:1px solid var(--border);color:#cfe8ff;border-radius:8px;padding:6px 8px
        }
        .deps-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
        @media (max-width:920px){.deps-grid{grid-template-columns:1fr}}
        .dep-item{display:grid;grid-template-columns:70px 1fr;gap:12px;align-items:center;border:1px solid var(--border);border-radius:12px;padding:10px;background:#0c1424}
        .dep-item .ring{width:56px;height:56px}
    </style>
</head>
<body>
<div class="page">
    <div class="header">
        <h1>Service Status · Glass Dashboard+</h1>
        <div class="actions">
            <button id="runAllButton">Run all</button>
            <button id="runBenchmarkButton">One-Click Benchmark</button>
        </div>
    </div>

    <div class="row">
        <div>Host: <code id="hostLabel"></code></div>
        <div>UA: <code id="userAgentLabel"></code></div>
    </div>

    <div class="grid" id="gridRoot">

        <!-- 外网可达 -->
        <div class="card" data-kind="ping">
            <div class="ring"><span id="latencyLabel-ping">—</span></div>
            <div class="kv">
                <div><b>外网可达</b> <span class="badge"><span class="dot idle"></span><span id="statusLabel-ping">IDLE</span></span></div>
                <div class="muted">GET <code id="endpointLabel-ping">/</code></div>
                <div class="row">
                    <button data-run="ping">Test</button>
                </div>
            </div>
        </div>

        <!-- 后端就绪 -->
        <div class="card" data-kind="health">
            <div class="ring"><span id="latencyLabel-health">—</span></div>
            <div class="kv">
                <div><b>后端就绪</b> <span class="badge"><span class="dot idle"></span><span id="statusLabel-health">IDLE</span></span></div>
                <div class="muted">GET <code id="endpointLabel-health">/healthy</code></div>
                <div class="row">
                    <button data-run="health">Test</button>
                </div>
            </div>
        </div>

        <!-- Redis 连接 -->
        <div class="card" data-kind="redis">
            <div class="ring"><span id="latencyLabel-redis">—</span></div>
            <div class="kv">
                <div><b>Redis 连接</b> <span class="badge"><span class="dot idle"></span><span id="statusLabel-redis">IDLE</span></span></div>
                <div class="muted">GET <code id="endpointLabel-redis">/status</code></div>
                <div class="row">
                    <button data-run="redis">Test</button>
                </div>
            </div>
        </div>

        <!-- 版本/构建信息 -->
        <div class="card" data-kind="info">
            <div class="ring"><span id="latencyLabel-info">—</span></div>
            <div class="kv">
                <div><b>版本信息</b> <span class="badge"><span class="dot idle"></span><span id="statusLabel-info">IDLE</span></span></div>
                <div class="muted">GET <code id="endpointLabel-info">/actuator/info</code></div>
                <div class="row">
                    <button data-run="info">Test</button>
                </div>
                <div class="muted" id="infoSummary" style="margin-top:6px">—</div>
            </div>
        </div>

        <!-- 延迟历史（持久化） -->
        <div class="card full" data-kind="history">
            <div class="kv" style="grid-column:1/-1">
                <div><b>延迟历史</b></div>
                <canvas class="spark" id="latencySparkline"></canvas>
                <div class="muted" id="latencyStats">—</div>
            </div>
        </div>

        <!-- 依赖面板（可配置多端点） -->
        <div class="card full" data-kind="deps">
            <div class="kv" style="grid-column:1/-1">
                <div class="row" style="justify-content:space-between;align-items:center">
                    <b>依赖</b>
                    <div class="row">
                        <button id="depsRunAllButton">Run</button>
                    </div>
                </div>
                <div class="deps-grid" id="depsGrid"></div>
            </div>
        </div>

        <!-- 静态资源热身（CDN/缓存预热） -->
        <div class="card full" data-kind="assets">
            <div class="kv" style="grid-column:1/-1">
                <div><b>静态资源热身</b></div>
                <div class="row">
                    <label>URL 列表 <input id="assetsInput" type="text" placeholder="/assets/a.js,/assets/b.css"/></label>
                    <label>并发 <input id="assetsConcurrencyInput" type="number" min="1" max="32" value="4"/></label>
                    <button id="assetsStartButton">Start</button>
                </div>
                <div class="progress" style="margin:8px 0"><span id="assetsProgressBar"></span></div>
                <div id="assetsStats" class="muted">—</div>
            </div>
        </div>

        <!-- 一键压测 -->
        <div class="card full" data-kind="bench">
            <div class="kv" style="grid-column:1/-1">
                <div><b>一键压测</b></div>
                <div class="row">
                    <label>Endpoint <input id="benchEndpointInput" type="text" value="/healthy" size="28"/></label>
                    <label>Total <input id="benchTotalInput" type="number" min="1" max="2000" value="100"/></label>
                    <label>Concurrency <input id="benchConcurrencyInput" type="number" min="1" max="64" value="8"/></label>
                    <label>Timeout(ms) <input id="benchTimeoutInput" type="number" min="100" max="60000" value="8000"/></label>
                    <button id="benchStartButton">Start</button>
                    <button id="benchAbortButton" disabled>Abort</button>
                </div>
                <div class="progress" style="margin:8px 0"><span id="benchProgressBar"></span></div>
                <div id="benchStats" class="muted">—</div>
            </div>
        </div>

        <!-- 预留：日志面板（UI 占位，不含文案） -->
        <div class="card full" data-kind="logs">
            <div class="kv" style="grid-column:1/-1">
                <div><b>日志</b></div>
                <div id="logsPlaceholder" style="height:220px;background:#070a0f;border:1px solid var(--border);border-radius:12px"></div>
            </div>
        </div>

    </div>

    <div class="muted"></div>
</div>

<script type="module">
    const queryParams = new URLSearchParams(location.search);
    const endpointConfiguration = {
      ping  : queryParams.get('ping')   || '/',
      health: queryParams.get('health') || '/healthy',
      redis : queryParams.get('redis')  || '/status',
      info  : queryParams.get('info')   || '/actuator/info',
      deps  : queryParams.get('deps')   || '',
      assets: queryParams.get('assets') || ''
    };
    const selectOne = (sel) => document.querySelector(sel);
    const classifyTier = (latencyMs, ok) => (!ok) ? 'bad' : latencyMs < 200 ? 'ok' : latencyMs < 800 ? 'warn' : 'bad';
    const colorByTier = (tier) =>
      tier === 'ok' ? getComputedStyle(document.documentElement).getPropertyValue('--ok').trim()
        : tier === 'warn' ? getComputedStyle(document.documentElement).getPropertyValue('--warn').trim()
        : getComputedStyle(document.documentElement).getPropertyValue('--bad').trim();

    async function httpRequestWithMetrics(url, options = {}) {
      const { timeoutMs = 8000, expectJson = false, ...init } = options;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort('timeout'), timeoutMs);
      const startedAt = performance.now();
      try {
        const response = await fetch(url, { cache:'no-store', mode:'same-origin', signal:controller.signal, ...init });
        const durationMs = performance.now() - startedAt;
        let parsed = undefined;
        if (expectJson) { try { parsed = await response.clone().json(); } catch {} }
        return { ok:response.ok, status:response.status, statusText:response.statusText, durationMs, data:parsed, redirected:response.redirected };
      } catch (error) {
        const durationMs = performance.now() - startedAt;
        return { ok:false, status:'ERR', statusText:String(error), durationMs, error, redirected:false };
      } finally { clearTimeout(timeoutId); }
    }

    function updateRing(element, progressDegree, tier) {
      element.style.background = `conic-gradient(${colorByTier(tier)} ${progressDegree}deg, var(--ringTrack) ${progressDegree}deg 360deg)`;
    }
    function updateCard(kind, result) {
      const statusElement = selectOne(`#statusLabel-${kind}`);
      const dotElement = statusElement?.previousElementSibling;
      const latencyElement = selectOne(`#latencyLabel-${kind}`);
      const tier = classifyTier(result.latencyMs ?? 0, result.ok);
      if (statusElement && dotElement && latencyElement) {
        statusElement.textContent = result.ok ? `OK (${result.status})` : `FAIL (${result.status})`;
        dotElement.className = `dot ${result.ok ? tier : 'bad'}`;
        latencyElement.textContent = Number.isFinite(result.latencyMs) ? `${Math.round(result.latencyMs)}ms` : '—';
      }
      if (kind === 'info' && result.note) {
        selectOne('#infoSummary').textContent = result.note;
      }
    }

    selectOne('#hostLabel').textContent = location.host || '—';
    selectOne('#userAgentLabel').textContent = navigator.userAgent;
    selectOne('#endpointLabel-ping').textContent   = endpointConfiguration.ping;
    selectOne('#endpointLabel-health').textContent = endpointConfiguration.health;
    selectOne('#endpointLabel-redis').textContent  = endpointConfiguration.redis;
    selectOne('#endpointLabel-info').textContent   = endpointConfiguration.info;

    const historyStoreKey = (name) => `gdp_latency_history::${location.origin}::${name}`;
    function loadLatencyHistory(name) {
      try {
        const raw = localStorage.getItem(historyStoreKey(name));
        if (!raw) return [];
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr : [];
      } catch { return []; }
    }
    function saveLatencyHistory(name, list) {
      try { localStorage.setItem(historyStoreKey(name), JSON.stringify(list)); } catch {}
    }
    const historyName = 'health';
    let latencyHistory = loadLatencyHistory(historyName).slice(-500);

    const sparkCanvas = selectOne('#latencySparkline');
    const sparkCtx = sparkCanvas.getContext('2d');
    function resizeSpark() {
      const dpr = Math.min(2, devicePixelRatio || 1);
      sparkCanvas.width  = sparkCanvas.clientWidth * dpr;
      sparkCanvas.height = sparkCanvas.clientHeight * dpr;
      sparkCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawSpark();
    }
    function percentile(values, q) {
      if (values.length === 0) return NaN;
      const copy = [...values].sort((a,b)=>a-b);
      const idx = Math.min(copy.length-1, Math.floor(q/100 * copy.length));
      return copy[idx];
    }
    function drawSpark() {
      const W = sparkCanvas.clientWidth, H = sparkCanvas.clientHeight;
      sparkCtx.clearRect(0,0,W,H);
      if (latencyHistory.length < 2) { selectOne('#latencyStats').textContent = '—'; return; }
      const sorted = [...latencyHistory].sort((a,b)=>a-b);
      const p50=Math.round(percentile(sorted,50)), p95=Math.round(percentile(sorted,95)), p99=Math.round(percentile(sorted,99));
      selectOne('#latencyStats').textContent = `p50 ${p50}ms · p95 ${p95}ms · p99 ${p99}ms · n=${latencyHistory.length}`;
      const max = Math.max(...latencyHistory);
      const stepX = W / (latencyHistory.length-1);
      sparkCtx.strokeStyle = '#3ab4ff'; sparkCtx.lineWidth = 2; sparkCtx.beginPath();
      latencyHistory.forEach((v,i)=>{
        const x = i*stepX, y = H - (v/max)*H;
        if(i===0) sparkCtx.moveTo(x,y); else sparkCtx.lineTo(x,y);
      });
      sparkCtx.stroke();
    }
    addEventListener('resize', resizeSpark, { passive:true });
    resizeSpark();

    function pushHistoryAndRedraw(latencyMs) {
      if (!Number.isFinite(latencyMs)) return;
      latencyHistory.push(Math.max(1, Math.round(latencyMs)));
      if (latencyHistory.length > 500) latencyHistory.shift();
      saveLatencyHistory(historyName, latencyHistory);
      drawSpark();
    }

    async function runPing() {
      const ring = selectOne('.card[data-kind="ping"] .ring');
      updateRing(ring, 45, 'warn');
      const res = await httpRequestWithMetrics(endpointConfiguration.ping);
      const tier = classifyTier(res.durationMs, res.ok);
      updateRing(ring, Math.min(330, 60 + Math.min(1000, res.durationMs)/1000*270), tier);
      updateCard('ping', { ok:res.ok, status:res.status, latencyMs:res.durationMs });
      return res;
    }
    async function runHealth() {
      const ring = selectOne('.card[data-kind="health"] .ring');
      updateRing(ring, 45, 'warn');
      const res = await httpRequestWithMetrics(endpointConfiguration.health);
      const tier = classifyTier(res.durationMs, res.ok);
      updateRing(ring, Math.min(330, 60 + Math.min(1000, res.durationMs)/1000*270), tier);
      updateCard('health', { ok:res.ok, status:res.status, latencyMs:res.durationMs });
      pushHistoryAndRedraw(res.durationMs);
      return res;
    }
    async function runRedis() {
      const ring = selectOne('.card[data-kind="redis"] .ring');
      updateRing(ring, 45, 'warn');
      const res = await httpRequestWithMetrics(endpointConfiguration.redis, { expectJson:true });
      let ok = res.ok;
      if (ok && res.data && Object.prototype.hasOwnProperty.call(res.data, 'redis')) {
        ok = String(res.data.redis).toLowerCase() === 'ok';
      }
      const tier = classifyTier(res.durationMs, ok);
      updateRing(ring, Math.min(330, 60 + Math.min(1000, res.durationMs)/1000*270), tier);
      updateCard('redis', { ok, status:res.status, latencyMs:res.durationMs });
      return res;
    }
    async function runInfo() {
      const ring = selectOne('.card[data-kind="info"] .ring');
      updateRing(ring, 45, 'warn');
      const res = await httpRequestWithMetrics(endpointConfiguration.info, { expectJson:true });
      const ok = res.ok;
      const tier = classifyTier(res.durationMs, ok);
      updateRing(ring, Math.min(330, 60 + Math.min(1000, res.durationMs)/1000*270), tier);
      const d = res.data || {};
      const v = d.build?.version || d.git?.commit?.id || d.version || d.app?.version || '';
      const n = d.app?.name || d.name || '';
      const tm = d.build?.time || d.time || d.timestamp || '';
      const note = [n, v && `@ ${v}`, tm && `· ${tm}`].filter(Boolean).join(' ');
      updateCard('info', { ok, status:res.status, latencyMs:res.durationMs, note: note || '—' });
      return res;
    }

    function parseDeps(input) {
      const list = [];
      if (!input) return list;
      input.split(',').forEach(pair=>{
        const idx = pair.indexOf(':');
        if (idx>0) {
          const name = decodeURIComponent(pair.slice(0, idx).trim());
          const path = pair.slice(idx+1).trim();
          if (name && path) list.push({name, path});
        }
      });
      return list;
    }
    const depsList = parseDeps(endpointConfiguration.deps);
    const depsGrid = selectOne('#depsGrid');
    function renderDeps() {
      depsGrid.innerHTML = '';
      depsList.forEach((d, i)=>{
        const item = document.createElement('div');
        item.className = 'dep-item';
        item.innerHTML = `
          <div class="ring"><span id="depLatency-${i}">—</span></div>
          <div class="kv">
            <div><b>${d.name}</b> <span class="badge"><span class="dot idle"></span><span id="depStatus-${i}">IDLE</span></span></div>
            <div class="muted">GET <code>${d.path}</code></div>
            <div class="row"><button data-dep-index="${i}">Test</button></div>
          </div>`;
        depsGrid.appendChild(item);
      });
      depsGrid.querySelectorAll('button[data-dep-index]').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const i = Number(btn.getAttribute('data-dep-index'));
          await runDependency(i);
        });
      });
    }
    renderDeps();

    async function runDependency(i) {
      const d = depsList[i]; if (!d) return;
      const ring = depsGrid.children[i].querySelector('.ring');
      updateRing(ring, 45, 'warn');
      const res = await httpRequestWithMetrics(d.path);
      const tier = classifyTier(res.durationMs, res.ok);
      updateRing(ring, Math.min(330, 60 + Math.min(1000, res.durationMs)/1000*270), tier);
      const statusEl = selectOne(`#depStatus-${i}`), dot = statusEl.previousElementSibling, msEl = selectOne(`#depLatency-${i}`);
      statusEl.textContent = res.ok ? `OK (${res.status})` : `FAIL (${res.status})`;
      dot.className = `dot ${res.ok ? tier : 'bad'}`;
      msEl.textContent = Number.isFinite(res.durationMs) ? `${Math.round(res.durationMs)}ms` : '—';
    }
    selectOne('#depsRunAllButton').addEventListener('click', async ()=>{
      for (let i=0;i<depsList.length;i++) await runDependency(i);
    });

    function parseAssets(input) {
      if (!input) return [];
      return input.split(',').map(s=>s.trim()).filter(Boolean);
    }
    const assetsInput = selectOne('#assetsInput');
    const assetsConcurrencyInput = selectOne('#assetsConcurrencyInput');
    const assetsProgressBar = selectOne('#assetsProgressBar');
    const assetsStats = selectOne('#assetsStats');

    function setAssetsProgress(done, total) {
      const percent = total===0 ? 0 : Math.round((done/total)*100);
      assetsProgressBar.style.width = percent + '%';
    }

    selectOne('#assetsStartButton').addEventListener('click', async ()=>{
      const list = parseAssets(assetsInput.value || endpointConfiguration.assets);
      const concurrency = Number(assetsConcurrencyInput.value) || 4;
      if (list.length === 0) { assetsStats.textContent = '—'; setAssetsProgress(0,1); return; }

      let done=0, ok=0, fail=0;
      setAssetsProgress(0, list.length);
      assetsStats.textContent = 'running...';

      const runOne = async (url) => {
        const res = await httpRequestWithMetrics(url, { timeoutMs: 12000 });
        done++; if (res.ok) ok++; else fail++;
        setAssetsProgress(done, list.length);
      };
      const q = [...list];
      const workers = Array.from({length: Math.min(concurrency, q.length)}, async ()=>{
        while(q.length){
          const url = q.shift();
          try{ await runOne(url);}catch{}
        }
      });
      await Promise.all(workers);
      assetsStats.textContent = `done ${done} · ok ${ok} · err ${fail}`;
    });

    let benchmarkAbortController = null;
    const benchEndpointInput = selectOne('#benchEndpointInput');
    const benchTotalInput = selectOne('#benchTotalInput');
    const benchConcurrencyInput = selectOne('#benchConcurrencyInput');
    const benchTimeoutInput = selectOne('#benchTimeoutInput');
    const benchStartButton = selectOne('#benchStartButton');
    const benchAbortButton = selectOne('#benchAbortButton');
    const benchProgressBar = selectOne('#benchProgressBar');
    const benchStats = selectOne('#benchStats');

    const benchCfgKey = `gdp_bench_cfg::${location.origin}`;
    try {
      const prev = JSON.parse(localStorage.getItem(benchCfgKey) || '{}');
      if (prev.endpoint) benchEndpointInput.value = prev.endpoint;
      if (prev.total) benchTotalInput.value = prev.total;
      if (prev.concurrency) benchConcurrencyInput.value = prev.concurrency;
      if (prev.timeoutMs) benchTimeoutInput.value = prev.timeoutMs;
    } catch {}

    function saveBenchCfg() {
      try {
        localStorage.setItem(benchCfgKey, JSON.stringify({
          endpoint: benchEndpointInput.value,
          total: Number(benchTotalInput.value),
          concurrency: Number(benchConcurrencyInput.value),
          timeoutMs: Number(benchTimeoutInput.value)
        }));
      } catch {}
    }

    function updateBenchmarkProgress(done, total) {
      const percent = total === 0 ? 0 : Math.round((done/total)*100);
      benchProgressBar.style.width = percent + '%';
    }
    function pctl(values, q) {
      if (values.length === 0) return NaN;
      const a = [...values].sort((x,y)=>x-y);
      const idx = Math.min(a.length-1, Math.floor(q/100*a.length));
      return a[idx];
    }
    async function runBenchmark() {
      const endpoint = benchEndpointInput.value || endpointConfiguration.health;
      const total = Number(benchTotalInput.value) || 100;
      const concurrency = Number(benchConcurrencyInput.value) || 8;
      const timeoutMs = Number(benchTimeoutInput.value) || 8000;
      saveBenchCfg();

      benchStartButton.disabled = true; benchAbortButton.disabled = false;
      updateBenchmarkProgress(0, total);
      benchStats.textContent = 'running...';

      benchmarkAbortController = new AbortController();
      let completed = 0, success = 0, failure = 0;
      const latencies = [];

      const worker = async () => {
        while (true) {
          const index = completed;
          if (index >= total || benchmarkAbortController.signal.aborted) break;
          completed++;
          const res = await httpRequestWithMetrics(endpoint, { timeoutMs });
          if (res.ok) { success++; latencies.push(res.durationMs); } else { failure++; }
          updateBenchmarkProgress(success + failure, total);
        }
      };
      await Promise.all(Array.from({length: Math.min(concurrency, total)}, worker));

      const p50 = Math.round(pctl(latencies, 50));
      const p95 = Math.round(pctl(latencies, 95));
      const p99 = Math.round(pctl(latencies, 99));
      const min = Math.round(Math.min(...latencies));
      const max = Math.round(Math.max(...latencies));
      const errRate = total === 0 ? 0 : Math.round((failure/total)*100);
      benchStats.textContent =
        `done ${success+failure}/${total} · ok ${success} · err ${failure} (${errRate}%)` +
        (latencies.length ? ` · min ${min}ms · p50 ${p50}ms · p95 ${p95}ms · p99 ${p99}ms · max ${max}ms` : '');

      benchStartButton.disabled = false; benchAbortButton.disabled = true;
      benchmarkAbortController = null;
    }
    function abortBenchmark() {
      if (benchmarkAbortController) {
        benchmarkAbortController.abort();
        benchStats.textContent += ' · aborted';
        benchStartButton.disabled = false; benchAbortButton.disabled = true;
      }
    }
    selectOne('#benchStartButton').addEventListener('click', runBenchmark);
    selectOne('#benchAbortButton').addEventListener('click', abortBenchmark);
    selectOne('#runBenchmarkButton').addEventListener('click', ()=>{ benchEndpointInput.value = endpointConfiguration.health; runBenchmark(); });

    document.querySelectorAll('[data-run]').forEach(button=>{
      button.addEventListener('click', async ()=>{
        const kind = button.getAttribute('data-run');
        if (kind === 'ping')   await runPing();
        if (kind === 'health') await runHealth();
        if (kind === 'redis')  await runRedis();
        if (kind === 'info')   await runInfo();
      });
    });
    selectOne('#runAllButton').addEventListener('click', async ()=>{
      await runPing(); await runHealth(); await runRedis(); await runInfo();
      if (depsList.length) { for (let i=0;i<depsList.length;i++) await runDependency(i); }
    });

    const depsList = (function parseDeps(input) {
      const list = [];
      if (!input) return list;
      input.split(',').forEach(pair=>{
        const idx = pair.indexOf(':');
        if (idx>0) {
          const name = decodeURIComponent(pair.slice(0, idx).trim());
          const path = pair.slice(idx+1).trim();
          if (name && path) list.push({name, path});
        }
      });
      return list;
    })(endpointConfiguration.deps);

    const depsGrid = selectOne('#depsGrid');
    (function renderDeps() {
      depsGrid.innerHTML = '';
      depsList.forEach((d, i)=>{
        const item = document.createElement('div');
        item.className = 'dep-item';
        item.innerHTML = `
          <div class="ring"><span id="depLatency-${i}">—</span></div>
          <div class="kv">
            <div><b>${d.name}</b> <span class="badge"><span class="dot idle"></span><span id="depStatus-${i}">IDLE</span></span></div>
            <div class="muted">GET <code>${d.path}</code></div>
            <div class="row"><button data-dep-index="${i}">Test</button></div>
          </div>`;
        depsGrid.appendChild(item);
      });
      depsGrid.querySelectorAll('button[data-dep-index]').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const i = Number(btn.getAttribute('data-dep-index'));
          await runDependency(i);
        });
      });
    })();

    selectOne('#latencyLabel-ping').textContent   = '—';
    selectOne('#latencyLabel-health').textContent = '—';
    selectOne('#latencyLabel-redis').textContent  = '—';
    selectOne('#latencyLabel-info').textContent   = '—';
</script>
</body>
</html>
